{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Problem statement"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Problem Statement\n",
    "When the company receives a loan application, then company has to make a decision for loan approval based on the applicant’s profile so there will be 2 types of risks are associated with the bank’s decision:\n",
    "\n",
    "- If the applicant is likely to repay the loan, then not approving the loan results in a loss of business to the company - If the applicant is not likely to repay the loan, i.e. he/she is likely to default, then approving the loan may lead to a financial loss for the company"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Objective\n",
    "\n",
    "* Data ingestion\n",
    "* Data Cleaning\n",
    "* univariate analysis\n",
    "* Bivariate analysis "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Data Loading"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import warnings\n",
    "import numpy as np\n",
    "import zipcodes\n",
    "import missingno as msno\n",
    "import plotly.express as px"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the session options\n",
    "%matplotlib inline\n",
    "pd.options.display.max_columns = None\n",
    "#pd.options.display.max_rows = None\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "pd.options.display.float_format = '{:,.2f}'.format"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv('loan.csv',low_memory=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.dtypes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Data Cleaning"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "## Remove all rows and columns those contains all null values\n",
    "df = df.dropna(axis=0,how='all')\n",
    "df = df.dropna(axis=1,how='all')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##remove all columns having same value\n",
    "loan_unique = df.nunique().sort_values()\n",
    "unique_col = loan_unique[loan_unique==1].index\n",
    "df.drop(unique_col,axis=1,inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##remove columns having null values more than 30%\n",
    "null_greater_30_per= df.isnull().sum()[df.isnull().sum()>=len(df)/3].index\n",
    "df.drop(null_greater_30_per,axis=1,inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#distribution of missing values\n",
    "\n",
    "plt.figure(figsize= (30,10))\n",
    "plt.bar(df.isnull().sum().index,df.isnull().sum())\n",
    "plt.xlabel(\"Column_names\" ,fontdict={'fontsize':20})\n",
    "plt.ylabel(\"Count of null values\",fontdict={'fontsize':20})\n",
    "plt.xticks(rotation=90)\n",
    "plt.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##check object datatypes and resolve them\n",
    "df.dtypes[df.dtypes==object].index"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##Remove month from term column\n",
    "\n",
    "print(\"----------Term----------\")\n",
    "df[\"term\"] = df[\"term\"].str.replace(' months','').astype('int32')\n",
    "print(df[\"term\"].nunique())\n",
    "print(df[\"term\"].unique())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##Remove % from int_rate (interest rate)\n",
    "\n",
    "print(\"--------int_rate---------\")\n",
    "df[\"int_rate\"] = df[\"int_rate\"].str.replace('%','').astype(float)\n",
    "print(df[\"int_rate\"].nunique())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##Grade will remain categorical\n",
    "print(\"----------grade-----------\")\n",
    "print(df[\"grade\"].unique())\n",
    "print(df[\"grade\"].nunique())\n",
    "\n",
    "\n",
    "print(\"----------subgrade-----------\")\n",
    "print(df[\"sub_grade\"].unique())\n",
    "print(df[\"sub_grade\"].nunique())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##emp_length : employment duration\n",
    "##0 for less than a year and 10 for 10 or more than 10 years\n",
    "print(\"-----------emp_length------------\")\n",
    "df['emp_length'] = df['emp_length'].str.replace(' years|year|\\+','')\n",
    "df['emp_length'] = df['emp_length'].str.replace('< 1','0')\n",
    "df[\"emp_length\"].fillna('Not Disclosed',inplace=True)\n",
    "print(df['emp_length'].unique())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##home_ownership\n",
    "print('-----home ownership------')\n",
    "print(df['home_ownership'].value_counts())\n",
    "###removing None as there only 3 \n",
    "df = df[~(df['home_ownership']==\"NONE\")]\n",
    "print(df['home_ownership'].value_counts())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"-------------issue_d-------------\")\n",
    "df['issue_d'] = pd.to_datetime(df['issue_d'],format='%b-%y')\n",
    "df['issue_d'].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#last_pymnt_d: Last month payment was received\n",
    "df[\"last_pymnt_d\"] = pd.to_datetime(df[\"last_pymnt_d\"],format='%b-%y')\n",
    "df[\"last_pymnt_d\"].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#last_credit_pull_d: The most recent month LC pulled credit for this loan\n",
    "df[\"last_credit_pull_d\"] = pd.to_datetime(df[\"last_credit_pull_d\"],format='%b-%y')\n",
    "df[\"last_credit_pull_d\"].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##target variable loan_status\n",
    "print(\"--------loan---------\")\n",
    "df.groupby(\"loan_status\").agg({'loan_status':'count'})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#url\n",
    "#check for domain name, as domain name is same for all the raws so does not have extra info.\n",
    "print(\"---------URL----------\")\n",
    "df['url'].apply(lambda x : x.split('/')[2]).value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#desc  : Loan Description provided by borrower\n",
    "##create extra column for length of decription\n",
    "df['desc'] = df['desc'].fillna('')\n",
    "df['len_desc'] = df['desc'].apply(lambda x : len(x.strip()))\n",
    "df['len_desc'].describe()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df['earliest_cr_line_dt']=pd.to_datetime(df['earliest_cr_line'],format='%b-%y')\n",
    "print(df['earliest_cr_line_dt'].min())\n",
    "print(df['earliest_cr_line_dt'].max())\n",
    "\n",
    "\n",
    "# earliest_cr_line: The month the borrower's earliest reported credit line was opened\n",
    "df[\"earliest_cr_line\"]= pd.to_datetime(df[\"earliest_cr_line\"],format='%b-%y')\n",
    "# Earliest credit line of 2068 doesn't make sense. This appears to be due to limitation in python. \n",
    "# Python datetime library can only read dates until 1968. \n",
    "\n",
    "df['earliest_cr_line_dt_fine']=df['earliest_cr_line_dt'].apply(lambda x :x.replace(year=x.year-100) if x.year > 2018 else x)\n",
    "print(df['earliest_cr_line_dt_fine'].min())\n",
    "print(df['earliest_cr_line_dt_fine'].max())\n",
    "df[\"earliest_cr_line\"].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Take timedelta of issue_date_dt and earliest_cr_line_dt_fine to determin the 'credit Age/History of applicant'. \n",
    "# Calculate the credit History in terms of years\n",
    "df['time_delta']=df['issue_d']-df['earliest_cr_line_dt_fine']\n",
    "df['time_delta_int']=df['time_delta']/np.timedelta64(1, 'Y')\n",
    "print(df['time_delta_int'].min())\n",
    "print(df['time_delta_int'].max())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#revol_util: Revolving line utilization rate, or the amount of credit the borrower is using relative to all available revolving credit.\n",
    "df[\"revol_util\"]=df[\"revol_util\"].str.replace('%','').astype(float)\n",
    "\n",
    "##fill null values with the median\n",
    "df.dropna(subset=['revol_util'],inplace=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# emp_title - Create a new derived column to categorize if the emp_title is disclosed or not\n",
    "df.emp_title.describe()\n",
    "df['emp_title_provided'] = np.where(np.logical_or(df['emp_title'].isnull(), df['emp_title'].str.strip() == ''), False, True)\n",
    "df['emp_title_provided'] = df['emp_title_provided'].apply(lambda x: 'Disclosed' if x is True else 'Not Disclosed')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#pub_rec_bankruptcies - Impute 'Not known' for the bankruptcies record where the data is not available. \n",
    "print('--- pub_rec_bankruptcies ----\\n')\n",
    "print(df.pub_rec_bankruptcies.unique())\n",
    "df.pub_rec_bankruptcies.fillna(value='Not Known',inplace=True)\n",
    "print(df.pub_rec_bankruptcies.unique())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.info()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Delete columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Drop columns that do not add any weight to the analysis\n",
    "df.drop(columns=['member_id','funded_amnt_inv','grade','sub_grade','emp_title',\\\n",
    "                       'url','desc','open_acc','total_acc',\\\n",
    "                       'title',\"zip_code\",'earliest_cr_line',\\\n",
    "                       'earliest_cr_line_dt','time_delta','out_prncp','out_prncp_inv','total_pymnt',\\\n",
    "                       'total_pymnt_inv','total_rec_prncp','total_rec_int','total_rec_late_fee',\\\n",
    "                       'recoveries','collection_recovery_fee','last_pymnt_amnt',\\\n",
    "                        'last_credit_pull_d','earliest_cr_line_dt_fine',\\\n",
    "                       'last_pymnt_d'],\n",
    "                        axis=1,inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.shape\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,10))\n",
    "sns.heatmap(df.corr(),annot=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##from above heatmap we can see the correlated varibles\n",
    "##funded amount, are corelated with each other\n",
    "##lets check the kind co correation\n",
    "plt.figure(figsize=(20,20))\n",
    "sns.pairplot(df[[\"loan_amnt\",'funded_amnt']])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ##from above the plot we can see both are positively correlated with each other, \n",
    "#drop funded_amount\n",
    "df = df.drop([\"funded_amnt\"],axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Extract fully paid and charged off loans for Segmented analysis\n",
    "loan_data_extract=df[df['loan_status']!='Current']\n",
    "# Check Size and print few observations\n",
    "print(loan_data_extract.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Check the missing numbers\n",
    "msno.bar(loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exploratory Data Analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Univariate analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import seaborn as sns\n",
    "\n",
    "\n",
    "def stack_plot(data,x=None,y=\"loan_status\",width = 600, height = 500):\n",
    "    data[x] = data[x].apply(lambda x: str(x))\n",
    "    df_stack = data.groupby([x,y]).size().reset_index()\n",
    "    df_stack['Percentage']=data.groupby([x,y]).size().groupby(level=0).apply(lambda x:100 * x/float(x.sum())).values\n",
    "\n",
    "    df_stack['Percentage'] =  df_stack['Percentage'].apply(lambda x: round(x,2)) \n",
    "    fig = px.bar(df_stack, x = x, y = 'Percentage', color = y\n",
    "        , barmode = 'stack',text=df_stack['Percentage'])\n",
    "    fig.update_layout(title = x,\n",
    "        xaxis_title = y, yaxis_title = 'Percentage', \n",
    "        width =width, height = height)\n",
    "    fig.show()\n",
    "\n",
    "def box_plot(data,x=None,y=None,fx=10,fy=8):\n",
    "    \n",
    "    fig=plt.figure(figsize=(fx, fy), dpi=70, facecolor='w', edgecolor='k')\n",
    "    sns.set(style=\"darkgrid\")\n",
    "    sns.boxplot(x=x,y=y,data=data,orient=\"v\",palette='pastel')\n",
    "    plt.show()\n",
    "\n",
    "def count_plot(data,columns,fx=16,fy=8):\n",
    "    \n",
    "    fig=plt.figure(figsize=(fx, fy), dpi=90, facecolor='w', edgecolor='k')\n",
    "    sns.set(style=\"darkgrid\")\n",
    "    i=1\n",
    "    for col in columns:\n",
    "        plt.subplot(2,3,i)\n",
    "        plt.xticks(rotation='vertical')\n",
    "        ax=sns.countplot(y=col,\n",
    "            data=data,\n",
    "            palette='pastel',\n",
    "            order=data[col].value_counts().index)  \n",
    "        i=i+1\n",
    "    \n",
    "    \n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Loan amount : The amount customer requested"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "box_plot(data= loan_data_extract,y='loan_amnt',x='loan_status')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##bin the Loan amount in buckets to check counts in buckets\n",
    "loan_data_extract['loan_amnt_bin_catlg'] = pd.cut(loan_data_extract['loan_amnt'], np.linspace(0, 35000, 8))\n",
    "count_plot(loan_data_extract,['loan_amnt_bin_catlg'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stack_plot(x='loan_amnt_bin_catlg',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION:__\n",
    "\n",
    "\n",
    "In general, as the loan amount is increasing, the percentage of the charged off loans is increasing.\n",
    "\n",
    "The percentage of Charged off loans is highest for the loan amounts in range 30000 - 35000. But, the number of   loans in this category are less.\n",
    "\n",
    "From the count plot, the highest number of loans is for 5000 - 10000, followed by 0 - 5000 and 10000 - 15000. With in top 3 high volume categories, the laons that all with in 0 -5000 are slightly likely to be charged off"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Term: term of loan"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count_plot(loan_data_extract,['term'])\n",
    "\n",
    "stack_plot(x='term',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observation__:\n",
    "\n",
    "Loans with longer tenure have high percentage of Charge Off applications. This indicates that customers who have longer commitments opted charge off due to varying financial circumstances over the time."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### int_rate: Interest rate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "box_plot(data= loan_data_extract,y='int_rate',x='loan_status')\n",
    "loan_data_extract['int_rate_bin'] = pd.cut(loan_data_extract['int_rate'], np.linspace(5, 25, 5))\n",
    "\n",
    "count_plot(loan_data_extract,['int_rate_bin'])\n",
    "\n",
    "stack_plot(x='int_rate_bin',y='loan_status',data=loan_data_extract)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION:__\n",
    "\n",
    "In general, the higher the interest rate is, the higher is the percentage of Charged off Loans.\n",
    "\n",
    "Loans with in interest rate 10 -15 are most frequent, followed by those with 5-10 and 15-20.\n",
    "\n",
    "However, the percentage of chareged Offs is high in 10-15, followed by 5-10.\n",
    "\n",
    "This analysis evidences, that there is some risk in issuing the High Interest Loans and additional due deligence is required while processing loan applications"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Installments"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# loan_data_extract['installment'].describe()\n",
    "box_plot(data= loan_data_extract,y='installment',x='loan_status')\n",
    "loan_data_extract['installment_bin'] = pd.cut(loan_data_extract['installment'], np.linspace(15, 1400, 4))\n",
    "\n",
    "count_plot(loan_data_extract,['installment_bin'])\n",
    "\n",
    "stack_plot(x='installment_bin',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION:__\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### emp_length: tenure of employee"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#box_plot(data= loan_data_extract,y='emp_length',x='loan_status')\n",
    "#loan_data_extract['int_rate_bin'] = pd.cut(loan_data_extract['int_rate'], np.linspace(5, 25, 5))\n",
    "\n",
    "count_plot(loan_data_extract,['emp_length'])\n",
    "\n",
    "stack_plot(x='emp_length',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION__:\n",
    "\n",
    "There is no clear trend of employment length impact on the charged off rate. Further investigation will be required to study this variable"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### home_ownership: type of home ownership rented, own or mortgage"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count_plot(loan_data_extract,['home_ownership'])\n",
    "\n",
    "stack_plot(x='home_ownership',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observation:__\n",
    "\n",
    "The home ownership with 'other' are charging off the loans at higher rate.\n",
    "\n",
    "This shows that 'other' category of the home ownership should be identified as risk. Further checks are required to understand\n",
    "the residency status."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### annual_inc: Annual income"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "loan_data_extract[\"annual_inc\"].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##let's do analysis for slaray more than 1 Lac seprately\n",
    "salary_grt_lakh= loan_data_extract[loan_data_extract[\"annual_inc\"]>100000]\n",
    "box_plot(data= salary_grt_lakh,y='annual_inc',x='loan_status')\n",
    "salary_grt_lakh['annual_inc_grt_lac_bin'] = pd.cut(salary_grt_lakh['annual_inc'], np.linspace(10000,600000,5))\n",
    "\n",
    "count_plot(salary_grt_lakh,['annual_inc_grt_lac_bin'])\n",
    "\n",
    "stack_plot(x='annual_inc_grt_lac_bin',y='loan_status',data=salary_grt_lakh)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##let's do analysis for slaray more than 1 Lac seprately\n",
    "salary_less_lakh= loan_data_extract[loan_data_extract[\"annual_inc\"]<100000]\n",
    "box_plot(data= salary_less_lakh,y='annual_inc',x='loan_status')\n",
    "salary_less_lakh['annual_inc_grt_lac_bin'] = pd.cut(salary_less_lakh['annual_inc'], np.linspace(4000,100000,10))\n",
    "\n",
    "count_plot(salary_less_lakh,['annual_inc_grt_lac_bin'])\n",
    "\n",
    "stack_plot(x='annual_inc_grt_lac_bin',y='loan_status',data=salary_less_lakh)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION:__\n",
    "\n",
    "Employee greater than 1 Lac salary:\n",
    "\n",
    "    we can see that employees with greater than 1L rang, those are getting heigher salary in range 4.5L t0 6.0L are more likely to chargedoff\n",
    "\n",
    "\n",
    "\n",
    "Employee less than 1 Lac salary:\n",
    "\n",
    "    we can see that employees with greater than 1L rang, those are getting lower salary salary in range 4k t0 15k are more likely to chargedoff\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### verification_status: Indicates if income was verified by LC, not verified, or if the income source was verified"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#loan_data_extract[\"verification_status\"]\n",
    "\n",
    "count_plot(loan_data_extract,['verification_status'])\n",
    "stack_plot(x='verification_status',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION__:\n",
    "\n",
    "\n",
    "In case of Income verification, the charge off rate is higher ,when the income has been verified.\n",
    "\n",
    "This shows, that income verification checks have no effect in case of Risky applications. The income verification process will need to be reviewed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### emp_title_provided and Decription_length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# emp_title_provided\n",
    "# Decription_length\n",
    "print(\"---------------------------------------------Decription_length------------------------------------------------\")\n",
    "box_plot(data= loan_data_extract,y='len_desc',x='loan_status')\n",
    "loan_data_extract['len_desc_bin'] = pd.cut(loan_data_extract['len_desc'], np.linspace(0, 500,5))\n",
    "\n",
    "count_plot(loan_data_extract,['len_desc_bin'])\n",
    "\n",
    "stack_plot(x='len_desc_bin',y='loan_status',data=loan_data_extract)\n",
    "\n",
    "\n",
    "print(\"-----------------------------------------------emp_title_provided------------------------------------------------\")\n",
    "count_plot(loan_data_extract,['emp_title_provided'])\n",
    "\n",
    "stack_plot(x='emp_title_provided',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION__:\n",
    "\n",
    "Apparently, the rate of charged off applications are higher in cases, where the Employee title was not disclosed.\n",
    "\n",
    "However, the 'Not Disclosed' is much less compared to 'Disclosed' category and that could have some bearing on this trend.\n",
    "Further Analysis will be required on Employee title to draw logical conclusions."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Purpose"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count_plot(loan_data_extract,['purpose'])\n",
    "\n",
    "stack_plot(x='purpose',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observation:__\n",
    "\n",
    "In general, the unsecured loans - like the small business loans, followed by educational loans are highly charged off.\n",
    "Debit Consolidation is the most common purpose"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Analyse Credit History - The difference in the issue date and earliest credit date\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "box_plot(data= loan_data_extract,y='time_delta_int',x='loan_status')\n",
    "loan_data_extract['time_delta_int_bin'] = pd.cut(loan_data_extract['time_delta_int'], np.linspace(2, 65,22))\n",
    "\n",
    "count_plot(loan_data_extract,['time_delta_int_bin'])\n",
    "\n",
    "stack_plot(x='time_delta_int_bin',y='loan_status',data=loan_data_extract)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observations__:\n",
    "\n",
    "There is a mixed trend in the charged off loans when plotted against the credit age.\n",
    "\n",
    "In general, a very low credit age meant, the financial profile of the applicant is not clear.\n",
    "\n",
    "A high credit age meant, the financial profile of the applicant is superseded by the age of the application.\n",
    "\n",
    "This trend is clearly visible in the above percentage stacked plot."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### inq_last_6mths"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "box_plot(data= loan_data_extract,y='inq_last_6mths',x='loan_status')\n",
    "#loan_data_extract['inq_last_6mths_bin'] = pd.cut(loan_data_extract['inq_last_6mths'], np.linspace(0, 11,3))\n",
    "\n",
    "count_plot(loan_data_extract,['inq_last_6mths'])\n",
    "\n",
    "stack_plot(x='inq_last_6mths',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION:__\n",
    "\n",
    "Considering both the count plot and stacked percentage plot, it is evident that, the higher the number of inquiries, the higher\n",
    "is the rate of charge off. This parameter shows the desperation of the customer for a credit line."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### pub_rec_bankruptcies: Number of public record bankruptcies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# box_plot(data= loan_data_extract,y='pub_rec',x='loan_status')\n",
    "#loan_data_extract['inq_last_6mths_bin'] = pd.cut(loan_data_extract['inq_last_6mths'], np.linspace(0, 11,3))\n",
    "\n",
    "count_plot(loan_data_extract,['pub_rec_bankruptcies'])\n",
    "\n",
    "stack_plot(x='pub_rec_bankruptcies',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION:__\n",
    "\n",
    "It is evident from the above chart that, the higher the bankruptcies are, the higher is the charge off rate."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### revol_bal : Total credit revolving balance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "loan_data_extract[\"revol_bal\"].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "box_plot(data= loan_data_extract,y='revol_util',x='loan_status')\n",
    "loan_data_extract['revol_util_bin'] = pd.cut(loan_data_extract['revol_bal'], np.linspace(0, 100,11))\n",
    "\n",
    "count_plot(loan_data_extract,['revol_util_bin'])\n",
    "\n",
    "stack_plot(x='revol_util_bin',y='loan_status',data=loan_data_extract)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__observation__:\n",
    "\n",
    "There is no clear evidance of revolving balance on charged off rates"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### addr_state"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#box_plot(data= loan_data_extract,y='addr_state',x='loan_status')\n",
    "#loan_data_extract['inq_last_6mths_bin'] = pd.cut(loan_data_extract['inq_last_6mths'], np.linspace(0, 11,3))\n",
    "\n",
    "count_plot(loan_data_extract,['addr_state'],22,18)\n",
    "\n",
    "stack_plot(x='addr_state',y='loan_status',data=loan_data_extract,width=1000,height=500)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__OBSERVATION:__\n",
    "\n",
    "As per the above state 'CA' has highest number of charged off applications.\n",
    "\n",
    "In terms of percentages, the loans are highly charged off in the state NE,NIU and AE.\n",
    "\n",
    "Observing the number of loans applied from each of these states, it is clear, that the number of applications are less and hence\n",
    "\n",
    "this behavior. Excluding the above outlier behavior, the state with highest charged off percentage is NV - Nevada."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### delinq_2yrs : The number of 30+ days past-due incidences of delinquency in the borrower's credit file for the past 2 years"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count_plot(loan_data_extract,['delinq_2yrs'],22,18)\n",
    "\n",
    "stack_plot(x='delinq_2yrs',y='loan_status',data=loan_data_extract,width=1000,height=500)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Observation__\n",
    "\n",
    "In general, LC is not accepting the customers with higher count of 'delinq_2years'.\n",
    "\n",
    "('delinq_2years' - Denotes how many 30+ days past with the incidences of delinquency in last 2 years)\n",
    "The general trend is, as the count of variable increases, the percentage of charged off loans increases.\n",
    "\n",
    "There is a definite chance of charging off loan when the delinq_2years is high. Additional checks are required to understand\n",
    "\n",
    "the financial profile of the applicant in such cases."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Bivariate Analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Anlysis of relation b/w homeownership, dti and loan status"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Chart the plots grouping home owner ship and loan staus and take median of dti\n",
    "fig=plt.figure(figsize=(6, 6), dpi=90, facecolor='w', edgecolor='k')\n",
    "sns.set(style=\"darkgrid\")\n",
    "sns.barplot(y='dti',x='home_ownership',hue='loan_status',\n",
    "            palette='pastel',\n",
    "            data=loan_data_extract.groupby(by=['home_ownership','loan_status'])['dti'].median().reset_index())\n",
    "plt.legend(loc='lower left')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Chart the plots grouping home owner ship and loan staus and take median of dti\n",
    "# Chart the plots grouping home owner ship and loan staus and take median of dti\n",
    "fig=plt.figure(figsize=(6, 6), dpi=90, facecolor='w', edgecolor='k')\n",
    "sns.set(style=\"darkgrid\")\n",
    "sns.barplot(y='annual_inc',x='int_rate_bin',hue='loan_status',\n",
    "            palette='pastel',\n",
    "            data=loan_data_extract.groupby(by=['int_rate_bin','loan_status'])['annual_inc'].median().reset_index())\n",
    "plt.legend(loc='lower left')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "interpreter": {
   "hash": "52956614b297084d971658e0873fe8dcef84fe2e6735e2061f8d37bf33dabab3"
  },
  "kernelspec": {
   "display_name": "Python 3.6.8 64-bit ('License_Extractor': virtualenv)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
